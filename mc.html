<!DOCTYPE html>
<html lang="en">
<head>
	<title>Marching cubes experimentation</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
		  color: #fff;
		  font-family: Monospace;
		  font-size: 13px;
		  text-align: center;

		  background-color: #000;
		  margin: 0px;
		  overflow: hidden;
		}

		#info {
		  color: #ffffff;
		  position: absolute;
		  top: 0px;
		  width: 100%;
		  padding: 5px;
		}

		a {
		  color: gold;
		}

		#oldie {
		  font-family: monospace;
		  font-size: 13px;

		  text-align: center;
		  background: rgb(0, 0, 50);
		  color: #fff;
		  padding: 1em;

		  width: 475px;
		  margin: 5em auto 0;

		  display: none;
		}
	</style>
</head>

<body>

	<div id="container"></div>
	<script src="lib/three.min.js"></script>
	<script src="threejsMC.js"></script>


	<script>
		/*
			Ideal scenario is that faces obscure each other even with alpha
			Even when wireframe??
			for the sake of squarish, keep the old version? Ugh
			You're also going to need to make it a sphere at some point

			Next task is to turn it into a standard mesh
			then how to squeeze the data in

			you want to fully understand this shit, not just glue together

			Could use this to manage memory better?
			https://threejs.org/examples/#webgl_test_memory
		*/

		function init()
		{
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var camera = new THREE.PerspectiveCamera( 45, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10 );
			camera.position.set( 0, 0, 2 );
			var scene = new THREE.Scene();

			var renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

			var container = document.getElementById( 'container' );
			container.appendChild( renderer.domElement );

			//intriguing
			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			// LIGHTS
			{
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0.5, 0.5, 1 );
				scene.add( light );

				var pointLight = new THREE.PointLight( 0xff3300 );
				pointLight.position.set( 0, -3/7, -1/7 );
				scene.add( pointLight );

				var ambientLight = new THREE.AmbientLight( 0x080808 );
				scene.add( ambientLight );
			}			

			var material = new THREE.MeshPhongMaterial( { 
				color: 0x05152D, 
				specular: 0x888888, 
				shininess: 250,
				transparent:true,
				opacity: 0.9
				 } );

			
			//making data
			var dimension = 63;
			var field = new Float32Array( dimension*dimension*dimension );
			
			{
				// Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after
				// a fixed distance, determined by strength and subtract.

				function addBallToField( ballx, bally, ballz, strength, subtract )
				{
					var sign = Math.sign( strength );
					strength = Math.abs( strength );

					var radius = dimension * Math.sqrt( strength / subtract ),
						zs = ballz * dimension,
						ys = bally * dimension,
						xs = ballx * dimension;

					var min_z = Math.floor( zs - radius ); if ( min_z < 1 ) min_z = 1;
					var max_z = Math.floor( zs + radius ); if ( max_z > dimension - 1 ) max_z = dimension - 1;
					var min_y = Math.floor( ys - radius ); if ( min_y < 1 ) min_y = 1;
					var max_y = Math.floor( ys + radius ); if ( max_y > dimension - 1 ) max_y = dimension - 1;
					var min_x = Math.floor( xs - radius ); if ( min_x < 1  ) min_x = 1;
					var max_x = Math.floor( xs + radius ); if ( max_x > dimension - 1 ) max_x = dimension - 1;


					// Don't polygonize in the outer layer because normals aren't
					// well-defined there.

					var x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;

					for ( z = min_z; z < max_z; z ++ ) {

						z_offset = dimension*dimension * z;
						fz = z / dimension - ballz;
						fz2 = fz * fz;

						for ( y = min_y; y < max_y; y ++ ) {

							y_offset = z_offset + dimension * y;
							fy = y / dimension - bally;
							fy2 = fy * fy;

							for ( x = min_x; x < max_x; x ++ ) {

								fx = x / dimension - ballx;
								val = strength / ( 0.000001 + fx * fx + fy2 + fz2 ) - subtract;
								if ( val > 0.0 ) field[ y_offset + x ] += val * sign;

							}

						}

					}

				};

				var subtract = 12;
				var strength = 0.95;
				// map.reset();
				//it's 1x1x1
				addBallToField(0.5, 0.5, 0.5, strength,subtract);
				addBallToField(0, 0, 0, strength,subtract);
				addBallToField(1, 0, 0, strength,subtract);
				addBallToField(1, 1, 0, strength,subtract);
			}

			var isolevel = 50.0
			var mcSystem = new initMcSystem();
			var clock = new THREE.Clock();
			clock.getDelta();
			var standardMesh = new THREE.Mesh( mcSystem.getGeometry(field,dimension,isolevel), material );
			standardMesh.position.set(-1,-1,-1)
			console.log(clock.getDelta()*1000);
			scene.add( standardMesh );

			function render()
			{
				// camera.position.applyAxisAngle(new THREE.Vector3(0,1,0),0.01)
				// camera.rotation.y += 0.01;

				requestAnimationFrame( render );
				renderer.render( scene, camera );
			}
			render()
		}

		init();

</script>

</body>
</html>
